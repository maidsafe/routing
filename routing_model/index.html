<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <style>
  body {
  margin:40px auto;
  max-width:800px;
  line-height:1.6;
  font-size:18px;
  color:#333;
  background:#f1f1f1;
  padding:0 10px
  }
  h1,h2,h3 {
  line-height: 1.2
  }
  .collapsible {
  background-color: #777;
  color: white;
  cursor: pointer;
  padding: 5px;
  border: 2px transparent;
  text-align: left;
  outline: none;
  }
  .active, .collapsible:hover {
  background-color: #333;
  }
  .content {
  padding: 0 18px;
  display: none;
  overflow: hidden;
  background-color: #e1e1e1;
  }
  </style>
</head>
<body>
  <h1>Node in the Network</h1>

  <h2>Node's entire lifetime</h2>
  <p>This section describes the flow a node will follow during its entire lifetime.<br>
  When they join the network, they won't yet be a member of any section.<br>
  First,they will have to bootstrap with their proxy node, receive a RelocateInfo and attempt to join the section that this RelocateInfo is pointing to.<br>
  Once they have a full section, they will be able to operate as a full section member.
  </p>
  <button class="collapsible">OWN_SECTION</button>
  <div class="content">
      <p> OWN_SECTION refers to this node's own section.<br>
      It is an Option&ltPrefix&gt.<br>
      While a node is being relocated, the value will be none. Once they get accepted into a section, it becomes Some(that_section_s_prefix)
  </p>
  </div>
  <button class="collapsible">BootstrapAndRelocate</button>
  <div class="content">
      <p>This function gets called when a node just joined the Network.<br>
      At this stage, we are connected to a proxy node and they indicate to us which section we should join.
      </p>
  </div>
  <button class="collapsible">StartTopMember</button>
  <div class="content">
      <p>Once a node has joined a section (indicated by OWN_SECTION.is_some()), they will be able to perform as a member of that section until they are relocated away from it.<br>
      See StartTopMember graph for details.
      </p>
  </div>
  <button class="collapsible">Rebootstrap</button>
  <div class="content">
      <p>First Create new identity with public key-pair<br/>
      The node connects to a proxy with the new identity to use for joining the new section as a full node.
      </p>
  </div>
  <button class="collapsible">JoiningRelocateCandidate</button>
  <div class="content">
      <p>Once a node knows where to be relocated, they will follow this flow to become a full member of the section.<br>
      This covers resource proof from the point of view of the node being resource-proofed.<br>
      The output of this function is an Option. If we fail resource proof, it is none, which means we will have to bootstrap again. If it is Some, it contains the RelocateInfo we need to join this section.<br>
    See JoiningRelocateCandidate graph for details.
      </p>
  </div>

  <div class="mermaid">
    graph TB

    Start --> LoopStart
    style Start fill:#f9f,stroke:#333,stroke-width:4px

    LoopStart --> HasSection
    HasSection(("Check?"))

    HasSection --"OWN_SECTION.is_none()"--> BootstrapAndRelocate
    BootstrapAndRelocate["BootstrapAndRelocate:<br/>Get RelocateInfo"]
    BootstrapAndRelocate --> ReBootstrapWithNewIdentity

    HasSection --"OWN_SECTION.is_some()"--> StartTopMember
    StartTopMember["StartTopMember<br/>"]
    style StartTopMember fill:#f9f,stroke:#333,stroke-width:4px
    StartTopMember --> ReBootstrapWithNewIdentity

    ReBootstrapWithNewIdentity["Rebootstrap<br/>with new relocated identity<br/>output: RelocateInfo"]
    style ReBootstrapWithNewIdentity fill:#f9f,stroke:#333,stroke-width:4px
    ReBootstrapWithNewIdentity --> JoiningRelocateCandidate

    JoiningRelocateCandidate["JoiningRelocateCandidate(RelocateInfo)<br/>output: JoiningApproved"]
    style JoiningRelocateCandidate fill:#f9f,stroke:#333,stroke-width:4px

    SetNodeApproaval["OWN_SECTION=JoiningApproved"]
    JoiningRelocateCandidate --> SetNodeApproaval

    SetNodeApproaval --> LoopEnd
    LoopEnd --> LoopStart
  </div>


  <h2>Node as a member of a section</h2>
  <p>Once a node has joined a section, they need to be ready to take on multiple roles simultaneously:<br>
  <ul>
    <li> Deal with relocation:<br>
         The section as a whole will sometimes act as the source and sometimes as the destination of relocations. This means nodes will sometimes relocate away from this section and sometimes relocate to this section. Nodes in this section will need to perform the right flow to deal with both of these situations.
    <li> Decide who's an elder or a plain old adult
  </ul>
  All of these flows are happening simultaneously, but they share a common event loop. At any time, either all flows or all but one flows  must be in a "wait" state.<br>
  If our section decides to relocates us, we will have to stop functioning as a member of our section and go back to the previous flow where we will "Rebootstrap" so we can become a member of a different section.
  </p>
  <div class="mermaid">
    graph TB
    style StartTopMember fill:#f9f,stroke:#333,stroke-width:4px
    style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px
    StartTopMember --> InitializeNodeInternalState
    InitializeNodeInternalState["intialise_node_internal_state()<br/><br/>(Parsed, Routing table...)"]
    InitializeNodeInternalState --> ConcurentStartElder

    ConcurentStartElder{"Concurrent<br/>start elder"}
    ConcurentStartElder --> StartTopLevelDst
    style StartTopLevelDst fill:#f9f,stroke:#333,stroke-width:4px

    ConcurentStartElder --> StartTopLevelSrc
    style StartTopLevelSrc fill:#f9f,stroke:#333,stroke-width:4px

    ConcurentStartElder --> StartCheckAndProcessElderChange
    style StartCheckAndProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px


    ConcurentStartElder --> WaitFor

    WaitFor(("Wait for 0:"))

    Rpc((RPC))
    WaitFor --> Rpc
    Rpc -- "RelocatedInfo RPC"-->  EndRoutine
    EndRoutine["EndRoutine: Kill all sub routines"]
</div>

  <h1>Destination section</h1>
  <p>As a member of a section, our section will sometimes receive a node that is being relocated. These  diagrams are from the point of view of one of the nodes in the section, doing its part to handle the node that is trying to relocate to this section.
  </p>
  <h2>Deciding when to accept an incoming relocation</h2>
  <p>This flow represents what we do when a section contacts us to relocate one of their nodes to our section.<br>
  The process starts as we receive an ExpectCandidate RPC from this node.<br>
  We vote for it in PARSEC to be sure all members of the section process it in the same order.<br>
  Once it reaches consensus, we are ready to process that candidate by letting them perform the resource_proof (see AcceptAsCandidate).<br>
  There are some subtleties, such as the fact that we only want to process one candidate at a time, but this is the general idea.
  </p>
  <button class="collapsible">RPC: ExpectCandidate</button>
  <div class="content">
    <p>We receive this RPC from a section that wants to relocate a node to our section.<br>
    The node is not communicating with us yet, only once we sent RelocateResponse RPC to the originating section.<br>
    On receiving it, we vote for ParsecExpectCandidate to process it in the same order as other members of our section.<br>
    It kickstarts the entire chain of events in this diagram.<br>
    Note that we could also see consensus on ParsecExpectCandidate before we ourselves voted for it in PARSEC, as long as enough members of our section did.
    </p>
  </div>
  <button class="collapsible">RPC: ResourceProofResponse/<br>CandidateInfo</button>
  <div class="content">
  <p>These RPCs should generally be handled during resource proof, in AcceptAsCandidate.<br>
  It could be that they reach us before we are ready to receive them. For instance, because although enough other nodes got consensus on ParsecExpectCandidate, I'm still a bit behind.<br>
  It's OK to discard the RPC in this case as the node who aims to be relocated here will perceive this as a timeout from our end and resend later.
  </p>
  </div>
  <button class="collapsible">ParsecOnline<br>ParsecPurgeCandidate</button>
  <div class=content>
    <p>These consensus outputs were voted for in AcceptAsCandidate.<br>
    The same node could be accepted by some nodes who would vote ParsecOnline, but also time out for some other nodes who would vote for ParsecPurgeCandidate.<br>
    If it's the case, we only want to process the first of these two events and discard the other one.<br>
    Because the "Wait for 2" loop in AcceptAsCandidate has higher precendence than the "Wait for 1" loop in this one, this is exactly what will happen.
    </p>
  </div>
  <button class="collapsible">shorter_prefix_section</button>
  <div class="content">
    <p>If we know of a section that has a shorter prefix than ours, we prefer for them to receive this incoming node rather than ourselves as it will help keep the Network's sections tree balanced.<br>
    This shorter_prefix_section is a function that will return None if we are the shortest of any section we know, Some if there is a better candidate.<br>
    If it is Some, we will relay the RPC to them instead of accepting the rellocation to our own section.
    </p>
  </div>
  <button class="collapsible">PROCESSING_CANDIDATE</button>
  <div class="content">
    <p>We want to accept at most one incoming relocation at a time into our section.<br>
    The local variable: PROCESSING_CANDIDATE indicates whether someone is already passing the resource proof process, so we can't accept anyone else for now.<br>
    When PROCESSING_CANDIDATE is true and we reach consensus on ParsecExpectCandidate, we send a RefuseCandidate RPC to the would-be-incoming-node so they can try another section or try again later.
    </p>
  </div>
  <button class="collapsible">AcceptAsCandidate</button>
  <div class="content">
    <p>If we are ready to accept an incoming node and we reach consensus on ParsecExpectCandidate, we will execute this flow to make them pass resource proof.<br>
    See AcceptAsCandidate diagram for details.
    </p>
  </div>
  <div class="mermaid">
      graph TB

      Start["StartTopLevelDst:<br/>No exit - Need Killed"]
      style Start fill:#f9f,stroke:#333,stroke-width:4px
      Start --> LoopStart
      LoopEnd --> LoopStart


      LoopStart --> WaitFor

      WaitFor((Wait for 1:))
      WaitFor --RPC--> RPC
      WaitFor --Parsec<br/>consensus--> ParsecConsensus

      RPC((RPC))
      DiscardRPC[Discard RPC]
      RPC --ExpectCandidate--> VoteParsecExpectCandidate
      RPC --ResourceProofResponse<br/>CandidateInfo--> DiscardRPC
      DiscardRPC --> LoopEnd

      ParsecConsensus((Parsec<br/>consensus))
      DiscardParsec["Discard<br/>Parsec<br/>event"]
      ParsecConsensus --ParsecExpectCandidate--> Balanced
      ParsecConsensus --ParsecOnline<br/>ParsecPurgeCandidate<br/>--> DiscardParsec
      DiscardParsec --> LoopEnd

      VoteParsecExpectCandidate["vote_for(<br/>ParsecExpectCandidate)<br/>to handle the RPC consistently"]
      VoteParsecExpectCandidate --> LoopEnd

      Balanced(("Check?<br/>(shared state)"))
      Balanced -- "shorter_prefix_section(<br/>).is_some()" --> Resend
      Balanced -- "shorter_prefix_section().is_none()<br/>PROCESSING_CANDIDATE==yes" --> SendRefuse
      Balanced -- "shorter_prefix_section().is_none()<br/>PROCESSING_CANDIDATE==No" --> SetCandidateYes

      Resend["send_rpc(<br/>ExpectCandidate)<br/>to shorter_prefix_section()"]
      Resend --> LoopEnd

      SendRefuse["send_rpc(<br/>RefuseCandidate)<br/>to source section"]
      SendRefuse --> LoopEnd

      SetCandidateYes["PROCESSING_CANDIDATE=yes<br/>(shared state)"]
      SetCandidateYes-->Concurrent0

      Concurrent0{"Concurrent<br/>paths"}
      Concurrent0 --> AcceptAsCandidate
      Concurrent0 --> LoopEnd


      AcceptAsCandidate["AcceptAsCandidate<br/>(shared state)"]
      style AcceptAsCandidate fill:#f9f,stroke:#333,stroke-width:4px
      AcceptAsCandidate --> SetCandidateNo

      SetCandidateNo["PROCESSING_CANDIDATE=no<br/>(shared state)"]
      SetCandidateNo-->LoopEnd

  </div>

  <h2>Resource proof from a destination's point of view</h2>
  <p>In the previous diagram, we ensured an incoming candidate would only be processed for resource_proof if we are the best fit we know and we are not currently processing another node.<br>
  This leads us here: to the resource proof.<br>
  We will first add this node to our peer_list with the sate ResourceProof and send a RelocateResponse to the source section.<br>
  This will let them know we are ready to process them.<br>
  They will then send their CandidateInfo to everyone in our section.<br>
  On receiving a valid CandidateInfo, I will send them a ResourceProof RPC. This gives them the "problem to solve". As they solve it, they will send me ResourceProofResponses. These will be parts of the proof. On receiving valid parts, I must send a ResourceProofReceipt. Once they finally send me the last valid part, they passed their resource proof and I vote for ParsecOnline (essentially accepting them as a member of my section).<br>
  At any time during this process, they may timeout, in which case I will decided to reject them and vote for ParsecPurgeCandidate.<br>
  This process ends once I reach consensus on either accepting or the candidate (ParsecOnline) or refusing them (ParsecPurgeCandidate).<br>
  These payloads are Opaque, which means that consensus may be reached without a quorum on either of these. For that reason, it is possible that both reach consensus, in which case the second one will be discarded in the flow above. It won't cause issues as consistency is the only property that matters here: if we accept someone who then went Offline, we will be able to detect they are Offline later with the standard Offline detection mechanism.
  </p>
  <button class="collapsible">GOT_CANDIDATE_INFO</button>
  <div class="content">
    <p>We only want to receive CandidateInfo once and we can't verify a ResourceProofResponse without knowing the CandidateInfo.<br>
    The local variable: GOT_CANDIDATE_INFO helps us stay on top of this.
    </p>
  </div>
  <button class="collapsible">VOTED_ONLINE</button>
  <div class="content">
    <p>Once we've voted a node online, we don't care to handle further ResourceProofResponses from them.<br>
    This local variable helps us with this.
    </p>
  </div>
  <div class="mermaid">
      graph TB
      AcceptAsCandidate["Accept As Candidate<br/> Shared state all peers proceed"]
      EndRoutine["End of AcceptAsCandidate<br/>(shared state)"]
      style AcceptAsCandidate fill:#f9f,stroke:#333,stroke-width:4px
      style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

      AcceptAsCandidate --> SendRelocateResponse

      SendRelocateResponse["add_node(NodeState=ResourceProof)<br/><br/>send_rpc(RelocateResponse)<br/>to source section<br/><br/>schedule(TimeoutAccept)"]
      WaitFor(("Wait for 2:<br/><br/>Only current<br/>candidate<br/>events"))
      VoteParsecPurgeCandidate["vote_for(<br/>ParsecPurgeCandidate)"]
      VoteParsecOnline["vote_for(<br/>NetworkEvent::Online)<br/><br/>VOTED_ONLINE=yes"]
      RequestRP["send_rpc(<br/>ResourceProof)<br/>to candidate<br/><br/>GOT_CANDIDATE_INFO=yes"]
      SendProofReceit["send_rpc(<br/>ResourceProofReceipt)<br/>for proof"]

      SendRelocateResponse --> LoopStart
      LoopStart-->WaitFor


      WaitFor -- Consensus--> Consensus
      Consensus((Consensus))
      Consensus -- ParsecPurgeCandidate<br/>consensused --> RemoveNode
      Consensus -- ParsecOnline<br/>consensused --> MakeOnline
      MakeOnline["set_node_state(<br/>Candidate,<br/>OnlineState)<br/><br/>send_rpc(<br/>NodeApproval)"]
      RemoveNode["purge_node_info(<br/>candidate node)"]
      RemoveNode --> EndRoutine
      MakeOnline --> EndRoutine

      WaitFor -- ResourceProofResponse<br/><br/>GOT_CANDIDATE_INFO==yes<br/>VOTED_ONLINE==no --> ProofResponse((Proof))
      ProofResponse -- Valid Part --> SendProofReceit
      ProofResponse -- Valid End --> VoteParsecOnline

      WaitFor -- CandidateInfo<br/><br/>GOT_CANDIDATE_INFO==no --> Info((Info))
      Info -- Valid<br/>CandidateInfo --> RequestRP
      Info -- Invalid<br/>CandidateInfo --> VoteParsecPurgeCandidate
      WaitFor -- TimeoutAccept<br/>expire --> VoteParsecPurgeCandidate

      RequestRP --> LoopEnd
      SendProofReceit-->LoopEnd
      VoteParsecOnline --> LoopEnd
      VoteParsecPurgeCandidate --> LoopEnd
      LoopEnd --> LoopStart
  </div>

  <h1>Source section</h1>
  <p>As members of a section, each node must keep track of how many "work units" other nodes have performed.<br>
      Once a node has done accumulated enough work units to gain age, the section must work together to relocate that node to a new section where they can become 1 age unit older.<br>
      These diagrams detail how this happens.
  </p>
  <h2>Deciding that a member of our section should be relocated away</h2>
  <p>In these diagrams, we are modeling the simple version of node ageing that we decided to implement for Fleming:<br>
  Work units are incremented for all nodes in the section every time a timeout reaches consenus. Because a quorum of elders must have voted for this timeout, the malicious nodes can't arbitrarily speed up the ageing of their nodes.<br>
  Once a node has accumulated enough work units to be relocated, if they're a non-elder adult node, we will enter TryRelocating to attempt relocating them away from our section. If they are an elder node, we will first wait for the Adult/Elder promotion/demotion flow to kick in and demote them to an adult. This will happen because we changed their state from Online to Relocating, which means that they will get demoted.<br>
  Also of note: we will only be actively relocating at most one node away from our section at a time.
  </p>
  <button class="collapsible">WorkUnitTimeout</button>
  <div class="content">
    <p>In the context of Fleming, nodes (especially adults) aren't doing meaningful work such as handling data.<br>
    As a proxy, we use a time based metric to estimate how much work nodes have done (i.e: how long they remained Online and responsive).<br>
    A local timeout wouldn't do here as it would allow malicious nodes to artificially age nodes in their sections faster. However, by reaching quorum on the fact a timeout happened, we ensure that at least one honest node has voted for the timeout.<br>
    All nodes start the WorkUnitTimeout. On expiry, they vote for a WorkUnitIncrement in PARSEC and restart the timer.
    </p>
  </div>
  <button class="collapsible">increment_nodes_work_units</button>
  <div class="content">
    <p>This function increments the number of work units for all members of my peer_list (remember that n_work_units is a member of the PeerState struct).<br>
    </p>
  </div>
  <button class="collapsible">RELOCATING</button>
  <div class="content">
    <p>RELOCATING is an Option&ltPublicId&gt. It represents the node that we decided to relocate next, if any. It could be an elder, but if it is, we will only change the state of that node rather than immediately relocate it.<br>
    If we reach consensus on a WorkUnitIncrement while RELOCATING.is_some() - or in other words, while we are already relocating a node away from this section - we simply discard the PARSEC event. It will be dealt with later, after at least one more WorkUnitTimeout.
    </p>
  </div>
  <button class="collapsible">get_node_to_relocate</button>
  <div class="content">
    <p>This function will return the best candidate for relocation, if any.<br>
    First, if any member of our peer_list has the state: RelocatingState, Some(them) will be returned.<br>
    This helps ensure we aren't relocating multiple nodes at the same time if we have to wait for an elder to be demoted.<br>
    If none of the nodes in our peer_list have that state, it can return for instance the node with the largest number of work units for which the number of work units is greater than 2^age.
    </p>
  </div>
  <button class="collapsible">set_node_state</button>
  <div class="content">
    <p>This function mutates our peer_list to set the state: RelocatingState for the node: RELOCATING.<br>
    inputs:<br>
    - RELOCATING<br>
    - state<br>
    side-effect:<br>
    - mutates peer_list
    </p>
  </div>
  <button class="collapsible">TryRelocating</button>
  <div class="content">
    <p>The flow a section follow to relocate one of its adult nodes away from itself.<br>
    See next diagram for details.
    </p>
  </div>
  <button class="collapsible">RefuseCandidate/<br>RelocateResponse</button>
  <div class="content">
    <p>Exactly one of these RPCs will be sent to us from the destination section as a response to our section's ExpectCandidate RPC (see TryRelocating for more context).<br>
    These must be handled here as it is possible that one of the nodes sees this event reach consensus before they were aware that an ExpectCandidate RPC was sent from our section to the destination.<br>
    When this happens, we will immediately vote for it in PARSEC as we need to act in the same order as anyone else in our section.
    </p>
  </div>
  <button class="collapsible">ParsecRefuseCandidate/<br>ParsecRelocateResponse</button>
  <div class="content">
    <p>Exactly one of these events should reach consensus, and it must be handled in TryRelocating as the "Wait" in there has a higher priority than the one in this flow.<br>
    If we ever see consensus for one of these here, we know there is a bug; so we can panic.
    </p>
  </div>
  <div class="mermaid">
      graph TB


      Start["StartTopLevelSrc:<br/>No exit - Need Killed"]
      style Start fill:#f9f,stroke:#333,stroke-width:4px
      Start --> StartWorkUnitTimeOut

      StartWorkUnitTimeOut["schedule(WorkUnitTimeOut)"]
      StartWorkUnitTimeOut --> LoopStart
      LoopEnd --> LoopStart

      LoopStart --> WaitFor

      WaitFor((Wait for 3:))
      WaitFor --Event--> Event
      WaitFor --RPC--> RPC
      WaitFor --Parsec<br/>consensus--> ParsecConsensus

      Event((Event))
      Event -- WorkUnitTimeOut<br/>Trigger --> VoteParsecRelocationTrigger
      VoteParsecRelocationTrigger["vote_for(WorkUnitIncrement)<br/>schedule(WorkUnitTimeOut)"]
      VoteParsecRelocationTrigger --> LoopEnd

      RPC((RPC))
      RPC --RefuseCandidate--> VoteParsecRefuseCandidate
      RPC --RelocateResponse--> VoteParsecRelocateResponse
      VoteParsecRefuseCandidate["vote_for(<br/>ParsecRefuseCandidate)<br/>to handle the RPC consistently"]
      VoteParsecRefuseCandidate --> LoopEnd
      VoteParsecRelocateResponse["vote_for(<br/>ParsecRelocateResponse)<br/>to handle the RPC consistently"]
      VoteParsecRelocateResponse --> LoopEnd


      ParsecConsensus((Parsec<br/>consensus))
      DiscardParsec["Discard<br/>Parsec<br/>event"]
      Bug["BUG: assert fail:<br/><br/>Section can only send either<br/>one of these RPC, and only for<br/>the candidate we are relocating"]

      ParsecConsensus -- WorkUnitIncrement consensused --> IncrementWorkUnit
      IncrementWorkUnit["increment_nodes_work_units()"]
      IncrementWorkUnit-->AlreadyRelocating
      AlreadyRelocating(("Check?"))


      AlreadyRelocating --"RELOCATING.is_none()"--> SetRelocating
      AlreadyRelocating --"RELOCATING.is_some()"--> DiscardParsec
      ParsecConsensus --"Any:<br/><br/>ParsecRefuseCandidate<br/><br/>ParsecRelocateResponse"--> Bug
      Bug
      DiscardParsec --> LoopEnd

      SetRelocating["RELOCATING=Some(get_node_to_relocate())"]
      SetRelocating --> SetRelocatingNodeState

      SetRelocatingNodeState["set_node_state(RELOCATING, RelocatingState)"]
      SetRelocatingNodeState --> isRelocatingElder

      isRelocatingElder(("Check?"))
      isRelocatingElder--"is_elder(RELOCATING)"-->ResetRelocating
      isRelocatingElder--"!is_elder(RELOCATING)"-->Concurrent0

      Concurrent0{"Concurrent<br/>paths"}
      Concurrent0 --> TryRelocating
      Concurrent0 --> LoopEnd

      TryRelocating["TryRelocating<br/>(shared state)"]
      style TryRelocating fill:#f9f,stroke:#333,stroke-width:4px
      TryRelocating-->ResetRelocating

      ResetRelocating["RELOCATING=None<br/>(shared state)"]
      ResetRelocating --> LoopEnd
  </div>

  <h2>Relocating a member of our section away from it</h2>
  <div class="mermaid">
      graph TB

      TryRelocating["TryRelocating<br/> Shared state all peers proceed"]
      EndRoutine["End of TryRelocating<br/>(shared state)"]
      style TryRelocating fill:#f9f,stroke:#333,stroke-width:4px
      style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

      TryRelocating --> SendExpectCandidate

      SendExpectCandidate["send_rpc(<br/>ExpectCandidate)"]
      SendExpectCandidate --> WaitFor

      WaitFor((Wait for 4:<br/><br/>Only current<br/>candidate<br/>events))
      WaitFor --Parsec<br/>consensus--> Consensus

      Consensus((Consensus))
      Consensus --"ParsecRefuseCandidate"--> EndRoutine
      Consensus --"ParsecRelocateResponse"--> SendPovableRelocateInfo

      SendPovableRelocateInfo["send_rpc(RelocatedInfo)<br/>to node<br/><br/>Includes RelocationResponse<br/>content and consensus<br/>Node may be already gone"]
      SendPovableRelocateInfo-->PurgeNodeInfos
      PurgeNodeInfos["purge_node_info(<br/>node)"]
      PurgeNodeInfos--> EndRoutine
  </div>

  <h1>Elder-only</h1>
  <h2>Process for Adult/Elder promotion and demotion including merge</h2>
  <p>This flow updates the elder status of our section nodes if needed.<br/>
     Because it is interlinked, it also handles merging section: When merging, no elder change can happen.<br/>
     However other flows continue, so relocating to and from the section is uninterupted:<br/>
     We have to be careful that the section follows up on relocation once merged, so we may want to avoid active relocation when merging.
  </p>

  <div class="mermaid">
      graph TB
      CheckAndProcessElderChange["StartCheckAndProcessElderMergeChange:<br/>No exit - Need Killed"]
      style CheckAndProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px

      CheckAndProcessElderChange -->  StartCheckElderTimeout
      StartCheckElderTimeout["schedule(<br/>CheckElderTimeout)"]
      StartCheckElderTimeout -->  LoopStart


      WaitFor(("Wait for 5:"))
      LoopStart --> WaitFor

      WaitFor -- Event --> Event
      Event((Event))
      Event-- CheckElder<br/>Timeout--> VoteCheckElderTimeout
      VoteCheckElderTimeout["vote_for(<br/>ParsecCheckElderTimeout)"]
      VoteCheckElderTimeout--> LoopEnd

      RPC((RPC))
      WaitFor -- RPC --> RPC
      RPC --Merge--> VoteParsecNeighbourMerge
      VoteParsecNeighbourMerge["vote_for(<br/>ParsecNeighbourMerge)"]
      VoteParsecNeighbourMerge --> LoopEnd

      Consensus((Consensus))
      WaitFor-- Parsec<br/>consensus --> Consensus

      Consensus -- "ParsecNeighbourMerge" --> SetNeighbourMerge
      SetNeighbourMerge["store_merge_infos(ParsecNeighbourMerge info)"]
      SetNeighbourMerge-->LoopEnd

      Consensus--"ParsecCheckElderTimeout"-->CheckMergeNeeded
      CheckMergeNeeded(("Check"))

      CheckMergeNeeded--"!merge_needed()<br/> and<br/>!has_merge_infos()"-->CheckElderChange
      CheckElderChange(("Check"))


      CheckElderChange --"check_elder_change()<br/><br/>Has elder changes: elder first ordered by:<br/>State=Online then age then name."--> Concurrent0

      Concurrent0{"Concurrent<br/>paths"}
      Concurrent0 --> ProcessElderChange
      Concurrent0 --> LoopEnd

      ProcessElderChange["ProcessElderChange(changes)"]
      style ProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px
      ProcessElderChange -->RestartTimeout

      CheckElderChange -- "No<br/>changes" --> RestartTimeout

      RestartTimeout["schedule(<br/>CheckElderTimeout)"]
      RestartTimeout-->LoopEnd

      CheckMergeNeeded --"merge_needed()<br/>or<br/>has_merge_infos()"-->Concurrent1


      Concurrent1{"Concurrent<br/>paths"}
      Concurrent1 --> ProcessMerge
      Concurrent1 --> LoopEnd

      ProcessMerge["ProcessMerge"]
      style ProcessMerge fill:#f9f,stroke:#333,stroke-width:4px
      ProcessMerge --> RestartTimeout

      LoopEnd --> LoopStart
  </div>

  <h2>Process Adult/Elder promotion and demotion needed from last check</h2>
  <p>Vote for Add for new elders, Remove for no longer elders and NewSectionInfo<br/>
     This handles any change, it does not care whether one or all elders are changed, this is decided by the calling function.
 </p>
  <div class="mermaid">
      graph TB
      ProcessElderChange["ProcessElderChange<br/>(Take elder changes)"]
      style ProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px

      EndRoutine["End of ProcessElderChange<br/>(shared state)"]
      style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

      ProcessElderChange -->  MarkAndVoteSwapNewElder
      MarkAndVoteSwapNewElder["vote_for(Add) for new elders<br/>vote_for(Remove) for now adults nodes<br/>vote_for(NewSectionInfo)<br/><br/>WAITED_VOTES.insert(all votes)"]
      MarkAndVoteSwapNewElder --> LoopStart

      WaitFor(("Wait for 5:"))
      LoopStart --> WaitFor

      Consensus((Consensus))
      WaitFor-- Parsec<br/>consensus --> Consensus

      Consensus -- "WAITED_VOTES.contains(vote)" --> OneVoteConsensused
      OneVoteConsensused["WAITED_VOTES.remove(vote)"]

      OneVoteConsensused --> WaitComplete
      WaitComplete(("Check?"))
      WaitComplete--"WAITED_VOTES<br/>.is_empty()<br/>(Wait complete)"-->MarkNewElderAdults
      MarkNewElderAdults["For all nodes:<br/>set_elder_status(node, is_elder)"]
      MarkNewElderAdults--> EndRoutine
      WaitComplete--"!WAITED_VOTES<br/>.is_empty()<br/>(Wait not complete)"--> LoopEnd

      LoopEnd --> LoopStart
  </div>

  <h2>ProcessMerge Sub-routine</h2>
  <p>Vote for ParsecOurMerge, and take over handling any ParsecNeighbourMerge.<br/>
     Complete when one merge has completed, and a NewSectionInfo is consensused.<br/>
     If Multi stage merges are required, they will require calling this function again<br/>
     <br/>
     store_merge_infos: Store the neighbour's merge info, may not be sibling in case of multi merge<br/>
     has_sibling_merge_info: Did we store the neighbour's merge info for our sibling<br/>
     merge_sibling_info_to_new_section: Remove the stored sibling's merge info and return the NewSectionInfo.<br/>
  </p>
  <div class="mermaid">
      graph TB
      ProcessMerge["ProcessMerge<br/>"]
      EndRoutine["End of ProcessMerge<br/>(shared state)"]
      style ProcessMerge fill:#f9f,stroke:#333,stroke-width:4px
      style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

      ProcessMerge -->  VoteOurMerge
      VoteOurMerge["vote_for(<br/>ParsecOurMerge)"]
      VoteOurMerge --> LoopStart

      WaitFor(("Wait for 5:"))
      LoopStart --> WaitFor

      Consensus((Consensus))
      WaitFor-- Parsec<br/>consensus --> Consensus
      Consensus -- "NewSectionInfo" --> CompleteMerge
      CompleteMerge["Complete_merge()<br/>(Start parsec with new genesis...)"]
      CompleteMerge --> MarkNewElderAdults

      MarkNewElderAdults["For all nodes:<br/>set_elder_status(node, is_elder)<br/>based on new section info"]
      MarkNewElderAdults--> EndRoutine

      Consensus -- "ParsecNeighbourMerge" --> SetNeighbourMerge
      SetNeighbourMerge["store_merge_infos(ParsecNeighbourMerge info)"]
      SetNeighbourMerge --> CheckMerge

      CheckMerge((Check))
      CheckMerge -- "OUR_MERGE<br/>and<br/>has_sibling_merge_info()" --> VotForNewSectionInfo
      VotForNewSectionInfo["OUR_MERGE=false<br/>merge_sibling_info_to_new_section()<br/>vote_for(<br/>NewSectionInfo)"]
      VotForNewSectionInfo--> LoopEnd


      CheckMerge -- "!OUR_MERGE<br/>or<br/>!has_sibling_merge_info()" --> LoopEnd

      Consensus--"ParsecOurMerge"-->SendMergeRpc
      SendMergeRpc["OUR_MERGE=true<br/>send_rpc(Merge)"]
      SendMergeRpc -->CheckMerge

      LoopEnd --> LoopStart
  </div>

  <h2>CheckOnlineOffline Sub-routine</h2>
  <div class="mermaid">
      graph TB
      CheckOnlineOffline["CheckOnlineOffline:<br/>No exit - Need Killed"]
      style CheckOnlineOffline fill:#f9f,stroke:#333,stroke-width:4px

      CheckOnlineOffline -->  LoopStart

      WaitFor(("Wait for 5:"))
      LoopStart --> WaitFor

      LocalEvent((Local<br/>Event))
      WaitFor --event--> LocalEvent

      LocalEvent -- Node detected offline --> VoteNodeOffline
      VoteNodeOffline["vote_for(<br/>ParsecOffline)"]
      VoteNodeOffline --> LoopEnd

      LocalEvent -- Node detected back online --> VoteNodeBackOnline
      VoteNodeBackOnline["vote_for(<br/>ParsecBackOnline)"]
      VoteNodeBackOnline --> LoopEnd

      Consensus((Consensus))
      WaitFor-- Parsec<br/>consensus --> Consensus
      Consensus--"ParsecOffline"-->SetOfflineState
      SetOfflineState["set_node_state(<br/>node,<br/>OfflineState)"]
      SetOfflineState -->LoopEnd

      Consensus -- "ParsecBackOnline" --> SetRelocating
      SetRelocating["set_node_state(<br/>node,<br/>RelocatingState)"]

      SetRelocating --> LoopEnd
      LoopEnd --> LoopStart
  </div>

  <h1>Elders and adults</h1>

  <h2>Becoming a full member of a section</h2>
  This is from the point of view of a node trying to join a section as a full member.<br/>
  This node is going to perform the resource proof until it receive a NodeApproval RPC to complete this stage successfully.<br/>
  If the node is not accepted, after time out, it will try another section.
  <div class="mermaid">
    graph TB
    JoiningRelocateCandidate -->  InitialSendConnectionInfoRequest
    JoiningRelocateCandidate["JoiningRelocateCandidate<br/>(Take destination section nodes)"]
    style JoiningRelocateCandidate fill:#f9f,stroke:#333,stroke-width:4px
    EndRoutine["End of JoiningRelocateCandidate<br/>"]
    style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

    InitialSendConnectionInfoRequest["For all nodes in destination section:<br/>MembersProofRequest(node) = None<br/>and send_rpc(ConnectionInfoRequest)<br/><br/>schedule(TimeoutResendInfo)<br/>schedule(TimeoutRefused)"]
    InitialSendConnectionInfoRequest-->LoopStart

    LoopStart --> WaitFor
    WaitFor(("Wait for 6:"))
    LocalEvent((Local<br/>Event))
    WaitFor --> LocalEvent

    LocalEvent -- ResourceProofForElderReady -->  SendFirstResourceProofPartForElder
    SendFirstResourceProofPartForElder["send_rpc(<br/>ResourceProofResponse)<br/>with first part for elder"]
    SendFirstResourceProofPartForElder --> LoopEnd

    LocalEvent--"TimeoutResendInfo triggered<br/> Some elders have not responsed<br/>with ResourceProof"--> ResendConnectionInfoRequest
    ResendConnectionInfoRequest["For all nodes with<br/>MembersProofRequest(node).is_none():<br/>send_rpc(ConnectionInfoRequest)<br/><br/>schedule(TimeoutResendInfo)"]
    ResendConnectionInfoRequest --> LoopEnd

    LocalEvent--"TimeoutRefused<br/>triggered"--> EndRoutine

    Rpc((RPC))
    WaitFor --> Rpc
    Rpc -- NodeApproval -->  EndRoutine

    Rpc -- ConnectionInfoResponse --> ConnectAndSendCandidateInfo
    ConnectAndSendCandidateInfo["Connect and send<br/>CandidateInfo"]
    ConnectAndSendCandidateInfo-->LoopEnd

    Rpc -- ResourceProofReceipt -->  SendNextResourceProofPartForElder
    SendNextResourceProofPartForElder["send_rpc(<br/>ResourceProofResponse)<br/>part for elder"]
    SendNextResourceProofPartForElder --> LoopEnd

    Rpc -- ResourceProof -->  StartComputeResourceProofForElder
    StartComputeResourceProofForElder["start_compute_resource_proof(source elder)"]
    StartComputeResourceProofForElder --> LoopEnd

    Rpc -- "ExpectCandidate<br/>RefuseCandidate<br/>RelocateResponse<br/>..." --> VoteParsecRPC
    VoteParsecRPC["vote_for(the parsec rpc)<br/>(cache for later)"]
    VoteParsecRPC --> LoopEnd

    LoopEnd --> LoopStart

  </div>



  <script src="mermaid.min.js"></script>
  <script>mermaid.initialize({startOnLoad:true});</script>
  <script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
</script>
</body>
</html>
