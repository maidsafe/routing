<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
</head>
<body>
  <h1>Top Flow</h1>

  <h2>Top Node Flow</h2>
  <div class="mermaid">
    graph TB

    Start --> LoopStart
    style Start fill:#f9f,stroke:#333,stroke-width:4px

    LoopStart --> IsMember
    IsMember((Section<br/>Member))

    IsMember --No--> BoostStrapAndRelocate
    BoostStrapAndRelocate["BoostStrapAndRelocate:<br/>Get RelocateInfo"]
    BoostStrapAndRelocate --> JoiningRelocateCandidate

    IsMember --Yes--> StartTopMember
    StartTopMember["StartTopMember<br/>Sub Routine<br/>"]
    style StartTopMember fill:#f9f,stroke:#333,stroke-width:4px
    StartTopMember --> JoiningRelocateCandidate

    JoiningRelocateCandidate["JoiningRelocateCandidate<br/>Sub Routine<br/><br/>(Take RelocatedInfo)"]
    style JoiningRelocateCandidate fill:#f9f,stroke:#333,stroke-width:4px

    JoiningRelocateCandidate --> LoopEnd
    LoopEnd --> LoopStart
</div>


  <h2>Top Member Flow</h2>
  <div class="mermaid">
    graph TB

    StartTopMember --> LoopStart

    style StartTopMember fill:#f9f,stroke:#333,stroke-width:4px
    style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

    LoopStart --> WaitFor
    WaitFor(("Wait for 6:"))

    Rpc((RPC))
    WaitFor --> Rpc
    Rpc -- "RelocatedInfo RPC"-->  EndRoutine

    Rpc -- BecomeElder RPC -->  ConcurentStartElder
    ConcurentStartElder{"Concurrent<br/>start elder"}
    ConcurentStartElder --> StartTopLevelElder
    style StartTopLevelElder fill:#f9f,stroke:#333,stroke-width:4px
    StartTopLevelElder --> LoopEnd

    ConcurentStartElder --> LoopEnd

    LoopEnd --> LoopStart


    EndRoutine["EndRoutine: Kill all sub routines"]
  </div>


  <h2>Top Elder Flow</h2>
  <div class="mermaid">
    graph TB
    style StartTopLevelElder fill:#f9f,stroke:#333,stroke-width:4px
    style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px
    StartTopLevelElder --> ConcurentStartElder

    ConcurentStartElder{"Concurrent<br/>start elder"}
    ConcurentStartElder --> StartTopLevelDst
    style StartTopLevelDst fill:#f9f,stroke:#333,stroke-width:4px

    ConcurentStartElder --> StartTopLevelSrc
    style StartTopLevelSrc fill:#f9f,stroke:#333,stroke-width:4px

    ConcurentStartElder --> WaitFor

    WaitFor(("Wait for 0:"))
    Event((Event))
    WaitFor --Event--> Event
    Event --StopElder Trigger--> EndRoutine
    EndRoutine["EndRoutine: Kill all sub routines"]
</div>

  <h1>Destination Section Flow</h1>
  <h2>Top Level Flow</h2>
  <div class="mermaid">
      graph TB

      Start["Start: No exit - Need Killed"]
      style Start fill:#f9f,stroke:#333,stroke-width:4px
      Start --> LoopStart
      LoopEnd --> LoopStart


      LoopStart --> WaitFor

      WaitFor((Wait for 1:))
      WaitFor --RPC--> RPC
      WaitFor --Parsec<br/>consensus--> ParsecConsensus

      RPC((RPC))
      DiscardRPC[Discard RPC]
      RPC --ExpectCandidate--> VoteParsecExpectCandidate
      RPC --ResourceProofResponse<br/>CandidateInfo--> DiscardRPC
      DiscardRPC --> LoopEnd

      ParsecConsensus((Parsec<br/>consensus))
      DiscardParsec["Discard<br/>Parsec<br/>event"]
      ParsecConsensus --ParsecExpectCandidate--> Balanced
      ParsecConsensus --ParsecOnline<br/>ParsecPurgeCandidate<br/>--> DiscardParsec
      DiscardParsec --> LoopEnd

      VoteParsecExpectCandidate[Vote for<br/>ParsecExpectCandidate<br/>to handle the RPC consistently]
      VoteParsecExpectCandidate --> LoopEnd

      Balanced(("Check Candidate?<br/>(shared state)"))
      Balanced -- Not shortest prefix --> Resend
      Balanced -- "Shortest prefix<br/>ProcessingCandidate=yes" --> SendRefuse
      Balanced -- "Shortest prefix<br/>ProcessingCandidate=No" --> SetCandidateYes

      Resend["Resend RPC <br/>ExpectCandidate<br/>to a shorter prefix section"]
      Resend --> LoopEnd

      SendRefuse["Send RPC<br/>RefuseCandidate<br/>to source section"]
      SendRefuse --> LoopEnd

      SetCandidateYes["ProcessingCandidate=yes<br/>(shared state)"]
      SetCandidateYes-->Concurrent0

      Concurrent0{"Concurrent<br/>paths"}
      Concurrent0 --> AcceptAsCandidate
      Concurrent0 --> LoopEnd


      AcceptAsCandidate["AcceptAsCandidate<br/>Sub Routine<br/>(shared state)"]
      style AcceptAsCandidate fill:#f9f,stroke:#333,stroke-width:4px
      AcceptAsCandidate --> CheckAndProcessElderChange

      CheckAndProcessElderChange["CheckAndProcessElderChange<br/>Sub Routine<br/>(shared state)"]
      style CheckAndProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px
      CheckAndProcessElderChange--> SetCandidateNo

      SetCandidateNo["ProcessingCandidate=no<br/>(shared state)"]
      SetCandidateNo-->LoopEnd

  </div>

  <h2>AcceptAsCandidate Sub-routine</h2>
  <div class="mermaid">
      graph TB
      AcceptAsCandidate["Accept As Candidate<br/> Shared state all peers proceed"]
      EndRoutine["End of AcceptAsCandidate<br/>(shared state)"]
      style AcceptAsCandidate fill:#f9f,stroke:#333,stroke-width:4px
      style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

      AcceptAsCandidate --> SendRelocateResponse

      SendRelocateResponse["Add Node State=ResourceProof<br/>Send RelocateResponse to source section<br/>Start TimeoutAccept"]
      WaitFor(("Wait for 2:<br/><br/>Only current<br/>candidate<br/>events"))
      VoteParsecPurgeCandidate[Vote for<br/>ParsecPurgeCandidate]
      VoteParsecOnline["Vote for<br/>NetworkEvent<br/>::Online<br/><br/>VotedOnline=yes"]
      RequestRP["Send ResourceProof<br/>RPC to candidate<br/><br/>GotCandidateInfo=yes"]
      SendProofReceit["Send receipt<br/>for proof"]

      SendRelocateResponse --> LoopStart
      LoopStart-->WaitFor


      WaitFor -- Consensus--> Consensus
      Consensus((Consensus))
      Consensus -- ParsecPurgeCandidate<br/>consensused --> RemoveNode
      Consensus -- ParsecOnline<br/>consensused --> MakeOnline
      MakeOnline["Node=OnlineState<br/><br/>Send NodeApproval RPC"]
      RemoveNode["Purge Candidate Node"]
      RemoveNode --> EndRoutine
      MakeOnline --> EndRoutine

      WaitFor -- ResourceProofResponse<br/><br/>GotCandidateInfo=yes<br/>VotedOnline=no --> ProofResponse((Proof))
      ProofResponse -- Valid Part --> SendProofReceit
      ProofResponse -- Valid End --> VoteParsecOnline

      WaitFor -- CandidateInfo<br/><br/>GotCandidateInfo=no --> Info((Info))
      Info -- Valid<br/>CandidateInfo --> RequestRP
      Info -- Invalid<br/>CandidateInfo --> VoteParsecPurgeCandidate
      WaitFor -- TimeoutAccept<br/>expire --> VoteParsecPurgeCandidate

      RequestRP --> LoopEnd
      SendProofReceit-->LoopEnd
      VoteParsecOnline --> LoopEnd
      VoteParsecPurgeCandidate --> LoopEnd
      LoopEnd --> LoopStart
  </div>

  <h1>Source Section Flow</h1>
  <h2>Top Level Flow</h2>
  <div class="mermaid">
      graph TB


      Start["Start: No exit - Need Killed"]
      style Start fill:#f9f,stroke:#333,stroke-width:4px
      Start --> LoopStart
      LoopEnd --> LoopStart

      LoopStart --> WaitFor

      WaitFor((Wait for 3:))
      WaitFor --Event--> Event
      WaitFor --RPC--> RPC
      WaitFor --Parsec<br/>consensus--> ParsecConsensus

      Event((Event))
      Event -- Detect<br/>Relocation<br/>Trigger --> VoteParsecRelocationTrigger
      VoteParsecRelocationTrigger["Vote for<br/>ParsecRelocationTrigger"]
      VoteParsecRelocationTrigger --> LoopEnd

      RPC((RPC))
      RPC --RefuseCandidate<br/>RelocateResponse--> DiscardRPC
      DiscardRPC --> LoopEnd

      ParsecConsensus((Parsec<br/>consensus))
      DiscardParsec["Discard<br/>Parsec<br/>event"]
      Bug["BUG:<br/><br/>Section can only send either<br/>one of these RPC, and only for<br/>the candidate we are Relocating"]

      ParsecConsensus --"ParsecRelocationTrigger<br/>Relocating.is_none()"--> SetRelocating
      ParsecConsensus --"ParsecRelocationTrigger<br/>Relocating.is_some()"--> DiscardParsec
      ParsecConsensus --"Any:<br/><br/>ParsecRefuseCandidate<br/><br/>ParsecRelocateResponse"--> Bug
      Bug
      DiscardParsec --> LoopEnd

      SetRelocating["Relocating=Some(Best Node)<br/>(Best if Node=RelocatingState)<br/>(shared state)"]
      SetRelocating --> SetRelocatingNodeState

      SetRelocatingNodeState["if not RelocatingState<br/>Relocating Node=RelocatingState"]
      SetRelocatingNodeState --> Concurrent0

      Concurrent0{"Concurrent<br/>paths"}
      Concurrent0 --> CheckAndProcessElderChange
      Concurrent0 --> LoopEnd

      CheckAndProcessElderChange["CheckAndProcessElderChange<br/>Sub Routine<br/>(shared state)"]
      style CheckAndProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px
      CheckAndProcessElderChange --> TryRelocating

      TryRelocating["TryRelocating<br/>Sub Routine<br/>(shared state)"]
      style TryRelocating fill:#f9f,stroke:#333,stroke-width:4px
      TryRelocating-->ResetRelocating

      ResetRelocating["Relocating=None<br/>(shared state)"]
      ResetRelocating --> LoopEnd
  </div>

  <h2>TryRelocating sub-routine</h2>
  <div class="mermaid">
      graph TB

      TryRelocating["TryRelocating<br/> Shared state all peers proceed"]
      EndRoutine["End of TryRelocating<br/>(shared state)"]
      style TryRelocating fill:#f9f,stroke:#333,stroke-width:4px
      style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

      TryRelocating --> SendExpectCandidate

      SendExpectCandidate["Send RPC <br/>ExpectCandidate"]
      SendExpectCandidate --> LoopStart
      LoopStart --> WaitFor
      LoopEnd --> LoopStart

      WaitFor((Wait for 4:<br/><br/>Only current<br/>candidate<br/>events))
      WaitFor --RPC--> RPC
      WaitFor --Parsec consensus<br/><br/>ParsecRefuseCandidate<br/>ParsecRelocateResponse--> Consensus

      Consensus((Consensus))
      Consensus --"ParsecRefuseCandidate"--> EndRoutine
      Consensus --"ParsecRelocateResponse"--> SendPovableRelocateInfo

      SendPovableRelocateInfo["Send RelocatedInfo RPC to node<br/><br/>Includes RelocationResponse<br/>content and consensus<br/>Node may be already gone"]
      SendPovableRelocateInfo-->PurgeNodeInfos
      PurgeNodeInfos["Purge Candidate Node info"]
      PurgeNodeInfos--> EndRoutine

      RPC((RPC))
      RPC --RefuseCandidate--> VoteParsecRefuseCandidate
      RPC --RelocateResponse--> VoteParsecRelocateResponse

      VoteParsecRefuseCandidate[Vote for<br/>ParsecRefuseCandidate<br/>to handle the RPC consistently]
      VoteParsecRefuseCandidate --> LoopEnd

      VoteParsecRelocateResponse[Vote for<br/>ParsecRelocateResponse<br/>to handle the RPC consistently]
      VoteParsecRelocateResponse --> LoopEnd
  </div>

  <h1>Common Elder Flow</h1>
  <h2>CheckAndProcessElderChange Sub-routine</h2>
  <div class="mermaid">
      graph TB
      CheckAndProcessElderChange["CheckAndProcessElderChange<br/>Sub Routine<br/>(shared state)"]
      EndRoutine["End of CheckAndProcessElderChange<br/>(shared state)"]
      style CheckAndProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px
      style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px


      MarkAndVoteSwapNewElder["Mark new Elder/Adults<br/><br/>Vote Add new nodes<br/>Vote Remove yougest elders<br/>Vote for new section"]

      CheckAndProcessElderChange -->  CheckElderChange

      CheckElderChange(("Check<br/>Elder<br/>change"))
      WaitFor(("Wait for 5:"))
      CheckElderChange -- "No changes" --> EndRoutine
      CheckElderChange -- "Has elder changes: elder first ordered by:<br/>State=Online then age then name." --> MarkAndVoteSwapNewElder
      MarkAndVoteSwapNewElder --> LoopStart
      LoopStart --> WaitFor

      WaitFor--"the 3 events <br/>consensused in Parsec"-->CheckNoLongerElder

      CheckNoLongerElder((Check<br/>no longer<br/>elder))
      CheckNoLongerElder -- Still elder --> EndRoutine
      CheckNoLongerElder -- No longer elder --> TriggerStopElder
      TriggerStopElder["Trigger StopElder<br/><br/>Do not exit sub routine<br/>Let it be killed by StopElder"]
      TriggerStopElder --> LoopEnd

      WaitFor--"one of the event<br/>consensused in Parsec"--> LoopEnd
      LoopEnd --> LoopStart
  </div>

  <h1>Non Elder Flow</h1>
  <h2>Joining Relocate Candidate Flow</h2>
  <div class="mermaid">
    graph TB
    JoiningRelocateCandidate -->  InitialConnectAndSendCandidateInfo
    JoiningRelocateCandidate["JoiningRelocateCandidate<br/>Sub Routine"]
    style JoiningRelocateCandidate fill:#f9f,stroke:#333,stroke-width:4px
    EndRoutine["End of JoiningRelocateCandidate<br/>"]
    style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

    InitialConnectAndSendCandidateInfo["Connect and send CandidateInfo<br/>to all section members<br/><br/>Start TimeoutResendInfo<br/>Start TimeoutRefused"]
    InitialConnectAndSendCandidateInfo-->LoopStart

    LoopStart --> WaitFor
    WaitFor(("Wait for 6:"))
    LocalEvent((Local<br/>Event))
    WaitFor --> LocalEvent

    LocalEvent -- ComputeResourceProofForElder -->  SendFirstResourceProofPartForElder
    SendFirstResourceProofPartForElder["Send first<br/>ResourceProofResponse<br/>part for elder"]
    SendFirstResourceProofPartForElder --> LoopEnd

    LocalEvent--"TimeoutResendInfo triggered<br/> Some section have not responsed<br/>with ResourceProof"--> ConnectAndSendCandidateInfo
    ConnectAndSendCandidateInfo["Connect and send CandidateInfo<br/>section members<br/>without ResourceProof<br/><br/>Restart TimeoutResendInfo"]
    ConnectAndSendCandidateInfo --> LoopEnd

    LocalEvent--"TimeoutRefused<br/>triggered"--> EndRoutine

    Rpc((RPC))
    WaitFor --> Rpc
    Rpc -- NodeApproval -->  EndRoutine

    Rpc -- ResourceProofReceipt -->  SendNextResourceProofPartForElder
    SendNextResourceProofPartForElder["Send next<br/>ResourceProofResponse<br/>part for elder"]
    SendNextResourceProofPartForElder --> LoopEnd

    Rpc -- ResourceProof -->  StartComputeResourceProofForElder
    StartComputeResourceProofForElder["Start compute<br/>ResourceProof<br/>for elder"]
    StartComputeResourceProofForElder --> LoopEnd

    LoopEnd --> LoopStart

  </div>



  <script src="https://unpkg.com/mermaid@8.0.0/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({startOnLoad:true});</script>
</body>
</html>