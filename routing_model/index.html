<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
</head>
<body>
  <h1>Top Flow</h1>

  <h2>Top Node Flow</h2>
  <div class="mermaid">
    graph TB

    Start --> LoopStart
    style Start fill:#f9f,stroke:#333,stroke-width:4px

    LoopStart --> HasSection
    HasSection(("Has Section<br/>NodeApproval"))

    HasSection --No--> BoostStrapAndRelocate
    BoostStrapAndRelocate["BoostStrapAndRelocate:<br/>Get RelocateInfo"]
    BoostStrapAndRelocate --> ReBootstrapWithNewIdentity

    HasSection --Yes--> StartTopMember
    StartTopMember["StartTopMember<br/>Sub Routine<br/>"]
    style StartTopMember fill:#f9f,stroke:#333,stroke-width:4px
    StartTopMember --> ReBootstrapWithNewIdentity

    ReBootstrapWithNewIdentity["Re-bootstrap with new relocated identity"]
    style ReBootstrapWithNewIdentity fill:#f9f,stroke:#333,stroke-width:4px
    ReBootstrapWithNewIdentity --> JoiningRelocateCandidate

    JoiningRelocateCandidate["JoiningRelocateCandidate<br/>Sub Routine<br/><br/>(Take RelocatedInfo)"]
    style JoiningRelocateCandidate fill:#f9f,stroke:#333,stroke-width:4px

    JoiningRelocateCandidate --> LoopEnd
    LoopEnd --> LoopStart
  </div>


  <h2>Top Member Flow</h2>
  <div class="mermaid">
    graph TB
    style StartTopMember fill:#f9f,stroke:#333,stroke-width:4px
    style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px
    StartTopMember --> InitializeNodeInternalState
    InitializeNodeInternalState["intialise_node_internal_state()<br/><br/>(Parsed, Routing table...)"]
    InitializeNodeInternalState --> ConcurentStartElder

    ConcurentStartElder{"Concurrent<br/>start elder"}
    ConcurentStartElder --> StartTopLevelDst
    style StartTopLevelDst fill:#f9f,stroke:#333,stroke-width:4px

    ConcurentStartElder --> StartTopLevelSrc
    style StartTopLevelSrc fill:#f9f,stroke:#333,stroke-width:4px

    ConcurentStartElder --> StartCheckAndProcessElderChange
    style StartCheckAndProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px


    ConcurentStartElder --> WaitFor

    WaitFor(("Wait for 0:"))

    Rpc((RPC))
    WaitFor --> Rpc
    Rpc -- "RelocatedInfo RPC"-->  EndRoutine
    EndRoutine["EndRoutine: Kill all sub routines"]
</div>

  <h1>Destination Section Flow</h1>
  Receiving a node that is being relocated.
  <h2>Top Level Flow</h2>
  <div class="mermaid">
      graph TB

      Start["StartTopLevelDst:<br/>No exit - Need Killed"]
      style Start fill:#f9f,stroke:#333,stroke-width:4px
      Start --> LoopStart
      LoopEnd --> LoopStart


      LoopStart --> WaitFor

      WaitFor((Wait for 1:))
      WaitFor --RPC--> RPC
      WaitFor --Parsec<br/>consensus--> ParsecConsensus

      RPC((RPC))
      DiscardRPC[Discard RPC]
      RPC --ExpectCandidate--> VoteParsecExpectCandidate
      RPC --ResourceProofResponse<br/>CandidateInfo--> DiscardRPC
      DiscardRPC --> LoopEnd

      ParsecConsensus((Parsec<br/>consensus))
      DiscardParsec["Discard<br/>Parsec<br/>event"]
      ParsecConsensus --ParsecExpectCandidate--> Balanced
      ParsecConsensus --ParsecOnline<br/>ParsecPurgeCandidate<br/>--> DiscardParsec
      DiscardParsec --> LoopEnd

      VoteParsecExpectCandidate["vote_for(<br/>ParsecExpectCandidate)<br/>to handle the RPC consistently"]
      VoteParsecExpectCandidate --> LoopEnd

      Balanced(("Check state?<br/>(shared state)"))
      Balanced -- "shorter_prefix_section(<br/>).is_some()" --> Resend
      Balanced -- "shorter_prefix_section().is_none()<br/>PROCESSING_CANDIDATE==yes" --> SendRefuse
      Balanced -- "shorter_prefix_section().is_none()<br/>PROCESSING_CANDIDATE==No" --> SetCandidateYes

      Resend["send_rpc(<br/>ExpectCandidate)<br/>to shorter_prefix_section()"]
      Resend --> LoopEnd

      SendRefuse["send_rpc(<br/>RefuseCandidate)<br/>to source section"]
      SendRefuse --> LoopEnd

      SetCandidateYes["PROCESSING_CANDIDATE=yes<br/>(shared state)"]
      SetCandidateYes-->Concurrent0

      Concurrent0{"Concurrent<br/>paths"}
      Concurrent0 --> AcceptAsCandidate
      Concurrent0 --> LoopEnd


      AcceptAsCandidate["AcceptAsCandidate<br/>Sub Routine<br/>(shared state)"]
      style AcceptAsCandidate fill:#f9f,stroke:#333,stroke-width:4px
      AcceptAsCandidate --> SetCandidateNo

      SetCandidateNo["PROCESSING_CANDIDATE=no<br/>(shared state)"]
      SetCandidateNo-->LoopEnd

  </div>

  <h2>AcceptAsCandidate Sub-routine</h2>
  <div class="mermaid">
      graph TB
      AcceptAsCandidate["Accept As Candidate<br/> Shared state all peers proceed"]
      EndRoutine["End of AcceptAsCandidate<br/>(shared state)"]
      style AcceptAsCandidate fill:#f9f,stroke:#333,stroke-width:4px
      style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

      AcceptAsCandidate --> SendRelocateResponse

      SendRelocateResponse["add_node(NodeState=ResourceProof)<br/><br/>send_rpc(RelocateResponse)<br/>to source section<br/><br/>Start TimeoutAccept"]
      WaitFor(("Wait for 2:<br/><br/>Only current<br/>candidate<br/>events"))
      VoteParsecPurgeCandidate["vote_for(<br/>ParsecPurgeCandidate)"]
      VoteParsecOnline["vote_for(<br/>NetworkEvent::Online)<br/><br/>VOTED_ONLINE=yes"]
      RequestRP["send_rpc(<br/>ResourceProof)<br/>to candidate<br/><br/>GOT_CANDIDATE_INFO=yes"]
      SendProofReceit["send_rpc(<br/>ResourceProofReceipt)<br/>for proof"]

      SendRelocateResponse --> LoopStart
      LoopStart-->WaitFor


      WaitFor -- Consensus--> Consensus
      Consensus((Consensus))
      Consensus -- ParsecPurgeCandidate<br/>consensused --> RemoveNode
      Consensus -- ParsecOnline<br/>consensused --> MakeOnline
      MakeOnline["set_node_state(<br/>Candidate,<br/>OnlineState)<br/><br/>send_rpc(<br/>NodeApproval)"]
      RemoveNode["purge_node_info(<br/>candidate node)"]
      RemoveNode --> EndRoutine
      MakeOnline --> EndRoutine

      WaitFor -- ResourceProofResponse<br/><br/>GOT_CANDIDATE_INFO==yes<br/>VOTED_ONLINE==no --> ProofResponse((Proof))
      ProofResponse -- Valid Part --> SendProofReceit
      ProofResponse -- Valid End --> VoteParsecOnline

      WaitFor -- CandidateInfo<br/><br/>GOT_CANDIDATE_INFO==no --> Info((Info))
      Info -- Valid<br/>CandidateInfo --> RequestRP
      Info -- Invalid<br/>CandidateInfo --> VoteParsecPurgeCandidate
      WaitFor -- TimeoutAccept<br/>expire --> VoteParsecPurgeCandidate

      RequestRP --> LoopEnd
      SendProofReceit-->LoopEnd
      VoteParsecOnline --> LoopEnd
      VoteParsecPurgeCandidate --> LoopEnd
      LoopEnd --> LoopStart
  </div>

  <h1>Source Section Flow</h1>
  <h2>Top Level Flow</h2>
  <div class="mermaid">
      graph TB


      Start["StartTopLevelSrc:<br/>No exit - Need Killed"]
      style Start fill:#f9f,stroke:#333,stroke-width:4px
      Start --> StartWorkUnitTimeOut

      StartWorkUnitTimeOut["Start WorkUnitTimeOut"]
      StartWorkUnitTimeOut --> LoopStart
      LoopEnd --> LoopStart

      LoopStart --> WaitFor

      WaitFor((Wait for 3:))
      WaitFor --Event--> Event
      WaitFor --RPC--> RPC
      WaitFor --Parsec<br/>consensus--> ParsecConsensus

      Event((Event))
      Event -- WorkUnitTimeOut<br/>Trigger --> VoteParsecRelocationTrigger
      VoteParsecRelocationTrigger["vote_for(WorkUnitIncrement)<br/>Restart WorkUnitTimeOut"]
      VoteParsecRelocationTrigger --> LoopEnd

      RPC((RPC))
      RPC --RefuseCandidate--> VoteParsecRefuseCandidate
      RPC --RelocateResponse--> VoteParsecRelocateResponse
      VoteParsecRefuseCandidate["vote_for(<br/>ParsecRefuseCandidate)<br/>to handle the RPC consistently"]
      VoteParsecRefuseCandidate --> LoopEnd
      VoteParsecRelocateResponse["vote_for(<br/>ParsecRelocateResponse)<br/>to handle the RPC consistently"]
      VoteParsecRelocateResponse --> LoopEnd


      ParsecConsensus((Parsec<br/>consensus))
      DiscardParsec["Discard<br/>Parsec<br/>event"]
      Bug["BUG: assert fail:<br/><br/>Section can only send either<br/>one of these RPC, and only for<br/>the candidate we are relocating"]

      ParsecConsensus -- WorkUnitIncrement consensused --> IncrementWorkUnit
      IncrementWorkUnit["increment_nodes_work_units()"]
      IncrementWorkUnit-->AlreadyRelocating
      AlreadyRelocating(("Already<br/>Relocating?"))


      AlreadyRelocating --"RELOCATING.is_none()"--> SetRelocating
      AlreadyRelocating --"RELOCATING.is_some()"--> DiscardParsec
      ParsecConsensus --"Any:<br/><br/>ParsecRefuseCandidate<br/><br/>ParsecRelocateResponse"--> Bug
      Bug
      DiscardParsec --> LoopEnd

      SetRelocating["RELOCATING=Some(get_node_to_relocate())<br/>(First with NodeState==RelocatingState)<br/>(shared state)"]
      SetRelocating --> SetRelocatingNodeState

      SetRelocatingNodeState["set_node_state(RELOCATING, RelocatingState)"]
      SetRelocatingNodeState --> isRelocatingElder

      isRelocatingElder(("Relocating<br/>elder?"))
      isRelocatingElder--"is_elder(RELOCATING)"-->ResetRelocating
      isRelocatingElder--"!is_elder(RELOCATING)"-->Concurrent0

      Concurrent0{"Concurrent<br/>paths"}
      Concurrent0 --> TryRelocating
      Concurrent0 --> LoopEnd

      TryRelocating["TryRelocating<br/>Sub Routine<br/>(shared state)"]
      style TryRelocating fill:#f9f,stroke:#333,stroke-width:4px
      TryRelocating-->ResetRelocating

      ResetRelocating["RELOCATING=None<br/>(shared state)"]
      ResetRelocating --> LoopEnd
  </div>

  <h2>TryRelocating sub-routine</h2>
  <div class="mermaid">
      graph TB

      TryRelocating["TryRelocating<br/> Shared state all peers proceed"]
      EndRoutine["End of TryRelocating<br/>(shared state)"]
      style TryRelocating fill:#f9f,stroke:#333,stroke-width:4px
      style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

      TryRelocating --> SendExpectCandidate

      SendExpectCandidate["send_rpc(<br/>ExpectCandidate)"]
      SendExpectCandidate --> WaitFor

      WaitFor((Wait for 4:<br/><br/>Only current<br/>candidate<br/>events))
      WaitFor --Parsec<br/>consensus--> Consensus

      Consensus((Consensus))
      Consensus --"ParsecRefuseCandidate"--> EndRoutine
      Consensus --"ParsecRelocateResponse"--> SendPovableRelocateInfo

      SendPovableRelocateInfo["send_rpc(RelocatedInfo)<br/>to node<br/><br/>Includes RelocationResponse<br/>content and consensus<br/>Node may be already gone"]
      SendPovableRelocateInfo-->PurgeNodeInfos
      PurgeNodeInfos["purge_node_info(<br/>node)"]
      PurgeNodeInfos--> EndRoutine
  </div>

  <h1>Common Elder Flow</h1>
  <h2>CheckAndProcessElderChange Sub-routine</h2>
  <div class="mermaid">
      graph TB
      CheckAndProcessElderChange["StartCheckAndProcessElderChange:<br/>No exit - Need Killed"]
      style CheckAndProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px

      CheckAndProcessElderChange -->  StartCheckElderTimeout
      StartCheckElderTimeout[Start<br/>CheckElderTimeout]
      StartCheckElderTimeout -->  LoopStart


      WaitFor(("Wait for 5:"))
       LoopStart --> WaitFor

      WaitFor -- Event --> Event
      Event((Event))
      Event-- CheckElder<br/>Timeout--> VoteCheckElderTimeout
      VoteCheckElderTimeout["vote_for(<br/>ParsecCheckElderTimeout)"]
      VoteCheckElderTimeout--> LoopEnd

      Consensus((Consensus))
      WaitFor-- Parsec<br/>consensus --> Consensus
      Consensus--"ParsecCheckElderTimeout"-->CheckElderChange
      CheckElderChange(("check_elder_change()"))
      CheckElderChange -- "Has elder changes: elder first ordered by:<br/>State=Online then age then name." --> MarkAndVoteSwapNewElder
      MarkAndVoteSwapNewElder["vote_for(Add) for new elders<br/>vote_for(Remove) for now adults nodes<br/>vote_for(NewSectionInfo)<br/><br/>WAITED_VOTES.insert(all votes)"]
      MarkAndVoteSwapNewElder -->LoopEnd


      CheckElderChange -- "No<br/>changes" --> RestartTimeout

      Consensus -- "WAITED_VOTES.contains(vote)" --> OneVoteConsensused
      OneVoteConsensused["WAITED_VOTES.remove(vote)"]

      OneVoteConsensused --> WaitComplete
      WaitComplete(("Wait<br/>is<br/>complete?"))
      WaitComplete--"WAITED_VOTES.is_empty()<br/>(complete)"-->MarkNewElderAdults
      MarkNewElderAdults["For all nodes:<br/>set_elder_status(node, is_elder)"]
      MarkNewElderAdults--> RestartTimeout
      RestartTimeout[Restart<br/>CheckElderTimeout]
      RestartTimeout-->LoopEnd
      WaitComplete--"!WAITED_VOTES.is_empty()<br/>(Not complete)"--> LoopEnd

      LoopEnd --> LoopStart
  </div>

  <h1>Non Elder Flow</h1>

  <h2>Re-bootstrap with new relocated identity</h2>
  First Create new identity with public key-pair<br/>
  The node connect to a proxy with the new identity to use for joining the new section as a full node.

  <h2>Joining Relocate Candidate Flow</h2>
  This is from the point of view of a node trying to join a section as a full member.<br/>
  This node is going to perform the resource proof until it receive a NodeApproval RPC to complete this stage successfully.<br/>
  If the node is not accepted, after time out, it will try another section.
  <div class="mermaid">
    graph TB
    JoiningRelocateCandidate -->  InitialSendConnectionInfoRequest
    JoiningRelocateCandidate["JoiningRelocateCandidate<br/>Sub Routine<br/>(Take destination section nodes)"]
    style JoiningRelocateCandidate fill:#f9f,stroke:#333,stroke-width:4px
    EndRoutine["End of JoiningRelocateCandidate<br/>"]
    style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

    InitialSendConnectionInfoRequest["For all nodes in destination section:<br/>MembersProofRequest(node) = None<br/>and send_rpc(ConnectionInfoRequest)<br/><br/>Start TimeoutResendInfo<br/>Start TimeoutRefused"]
    InitialSendConnectionInfoRequest-->LoopStart

    LoopStart --> WaitFor
    WaitFor(("Wait for 6:"))
    LocalEvent((Local<br/>Event))
    WaitFor --> LocalEvent

    LocalEvent -- ResourceProofForElderReady -->  SendFirstResourceProofPartForElder
    SendFirstResourceProofPartForElder["send_rpc(<br/>ResourceProofResponse)<br/>with first part for elder"]
    SendFirstResourceProofPartForElder --> LoopEnd

    LocalEvent--"TimeoutResendInfo triggered<br/> Some elders have not responsed<br/>with ResourceProof"--> ResendConnectionInfoRequest
    ResendConnectionInfoRequest["For all nodes with<br/>MembersProofRequest(node).is_none():<br/>send_rpc(ConnectionInfoRequest)<br/><br/>Restart TimeoutResendInfo"]
    ResendConnectionInfoRequest --> LoopEnd

    LocalEvent--"TimeoutRefused<br/>triggered"--> EndRoutine

    Rpc((RPC))
    WaitFor --> Rpc
    Rpc -- NodeApproval -->  EndRoutine

    Rpc -- ConnectionInfoResponse --> ConnectAndSendCandidateInfo
    ConnectAndSendCandidateInfo["Connect and send<br/>CandidateInfo"]
    ConnectAndSendCandidateInfo-->LoopEnd

    Rpc -- ResourceProofReceipt -->  SendNextResourceProofPartForElder
    SendNextResourceProofPartForElder["send_rpc(<br/>ResourceProofResponse)<br/>part for elder"]
    SendNextResourceProofPartForElder --> LoopEnd

    Rpc -- ResourceProof -->  StartComputeResourceProofForElder
    StartComputeResourceProofForElder["start_compute_resource_proof(source elder)"]
    StartComputeResourceProofForElder --> LoopEnd

    Rpc -- "ExpectCandidate<br/>RefuseCandidate<br/>RelocateResponse<br/>..." --> VoteParsecRPC
    VoteParsecRPC["vote_for(the parsec rpc)<br/>(cache for later)"]
    VoteParsecRPC --> LoopEnd

    LoopEnd --> LoopStart

  </div>



  <script src="mermaid.min.js"></script>
  <script>mermaid.initialize({startOnLoad:true});</script>
</body>
</html>